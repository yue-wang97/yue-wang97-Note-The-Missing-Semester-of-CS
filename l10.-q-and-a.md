# L10. Q&A

## Operating Systems 

Some good resources to learn about this topic:

* [MIT’s 6.828 class](https://pdos.csail.mit.edu/6.828/) - Graduate level class on Operating System Engineering. Class materials are publicly available.
* Modern Operating Systems \(4th ed\) - by Andrew S. Tanenbaum is a good overview of many of the mentioned concepts.
* The Design and Implementation of the FreeBSD Operating System - A good resource about the FreeBSD OS \(note that this is not Linux\).
* Other guides like [Writing an OS in Rust](https://os.phil-opp.com/) where people implement a kernel step by step in various languages, mostly for teaching purposes.

## the tools you’d prioritize learning first

Some topics worth prioritizing:

* Learning how to use your **keyboard** more and your mouse less. This can be through keyboard shortcuts, changing interfaces, &c.
* **text editor.** As a programmer most of your time is spent editing files so it really pays off to learn this skill well.
* how to **automate and/or simplify repetitive tasks** in your workflow because the time savings will be enormous…
* **version control** tools like Git and how to use it in conjunction with GitHub to collaborate in modern software projects.

### When do I use Python versus a Bash scripts versus some other language <a id="when-do-i-use-python-versus-a-bash-scripts-versus-some-other-language"></a>

bash scripts are useful for short and simple one-off scripts when you just want to run a specific series of commands. bash has a set of oddities that make it hard to work with for larger programs or scripts:

* bash is easy to get right for a simple use case but it can be really hard to get right for all possible inputs. For example, spaces in script arguments have led to countless bugs in bash scripts.
* bash is not amenable to code reuse so it can be hard to reuse components of previous programs you have written. More generally, there is no concept of software libraries in bash.
* bash relies on many magic strings like `$?` or `$@` to refer to specific values, whereas other languages refer to them explicitly, like `exitCode` or `sys.args` respectively.

Therefore, for larger and/or more complex scripts we recommend using more mature scripting languages like Python or Ruby. You can find online countless libraries that people have already written to solve common problems in these languages. If you find a library that implements the specific functionality you care about in some language, usually the best thing to do is to just use that language.



## difference between `source script.sh` and `./script.sh`

In both cases the `script.sh` will be read and executed in a bash session, 

the difference lies in which session is running the commands.

* `source:` the commands are **executed in your current bash session** and thus any changes made to the current environment, like changing directories or defining functions will persist in the current session once the `source` command finishes executing.
* `./script.sh`, your current bash session **starts a new instance of bash that will run the commands in `script.sh`**. Thus, if `script.sh` changes directories, the new bash instance will change directories but once it exits and returns control to the parent bash session, the parent session will remain in the same place. 
*  if `script.sh` defines **a function that you want to access in your terminal**, you need to `source` it for it to be defined in your current bash session. Otherwise, if you run it, the new bash process will be the one to process the function definition instead of your current shell.

## the places where various packages and tools are stored and how does referencing them work? What even is `/bin` or `/lib`?

they are all found in the directories listed in your `PATH` environment variable and you can use the `which` command \(or the `type` command\) to check where your shell is finding a specific program. 

check the [Filesystem, Hierarchy Standard](https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard) for a more comprehensive list.

* `/bin` - Essential command binaries
* `/sbin` - Essential system binaries, usually to be run by root
* `/dev` - Device files, special files that often are interfaces to hardware devices
* `/etc` - Host-specific system-wide configuration files
* `/home` - Home directories for users in the system
* `/lib` - Common libraries for system programs
* `/opt` - Optional application software
* `/sys` - Contains information and configuration for the system \(covered in the [first lecture](https://missing.csail.mit.edu/2020/course-shell/)\)
* `/tmp` - Temporary files \(also `/var/tmp`\). Usually deleted between reboots.
* `/usr/` - Read only user data
  * `/usr/bin` - Non-essential command binaries
  * `/usr/sbin` - Non-essential system binaries, usually to be run by root
  * `/usr/local/bin` - Binaries for user compiled programs
* `/var` - Variable files like logs or caches

## `apt-get install` a python-whatever, or `pip install` whatever package?

It’s related to whether you should use your system’s package manager or a language-specific package manager to install software.





